<!DOCTYPE html>
<html>
<head>
  <title>
    Vue.js color picker
  </title>

  <style>

    /* styling the sliders */
    input[type=range] {
      -webkit-appearance: none;
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 300px;
      height: 5px;
      background: #ddd;
      border: none;
      border-radius: 3px;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      border: none;
      height: 16px;
      width: 16px;
      border-radius: 50%;
      margin-top: -5px;
    }

    input[type=range]:focus {
      outline: none;
    }
    input[type=range]:focus::-webkit-slider-runnable-track {
      background: #ccc;
    }
    .red-slider::-webkit-slider-thumb {
      background: #ff4444;
    }
    .green-slider::-webkit-slider-thumb {
      background: #44ff44;
    }
    .blue-slider::-webkit-slider-thumb {
      background: #4444ff;
    }
    .darkness-slider::-webkit-slider-thumb {
      background: #444444;
    }
    .brightness-slider::-webkit-slider-thumb {
      background: #aaaaaa;
    }
    /* end styling sliders */

  </style>


</head>

<body>

<div id="color_swatch_selector">
  <div style=" position:relative; width:100px; height:100px; border:1px solid black;" v-bind:style="{ backgroundColor: colorStyle }" class="color_swatch">

  </div>
  <div class="debug_window">
    {{ channel_R }},{{ channel_G }},{{ channel_B }}
  </div>
  <div class="controllers">
    <input class="red-slider" type="range" v-model="channel_R" min="0" max="255" > Red <br>
    <input class="green-slider" type="range" v-model="channel_G" min="0" max="255" > Green <br>
    <input class="blue-slider" type="range" v-model="channel_B" min="0" max="255" > Blue <br>
    <input class="darkness-slider" type="range" v-model="darkness" min="0" max="255" > Darkness <br>
    <input class="brightness-slider" type="range" v-model="brightness" min="0" max="255" > Brightness <br>
  </div>

</div>

<script src="https://unpkg.com/vue/dist/vue.js"></script>

<script>

  // TODO: Make this color swatch using components

  var aw = new Vue({

    // "el" is which element on the page this Vue is attached to.
    el: '#color_swatch_selector',
    data: {
      channel_R:0,
      channel_G:0,
      channel_B:0,
      dark_ratios: [0, 0, 0],
      bright_ratios: [0, 0, 0],
      darkness:0,
      brightness:0,
      rgba:'rgba(255,0,0,1)'

    },

    watch: {
      channel_R: function() {
        this.updateRatios();
        this.updateDarkness();
        this.updateBrightness();
      },
      channel_G: function() {
        this.updateRatios();
        this.updateDarkness();
        this.updateBrightness();
      },
      channel_B: function() {
        this.updateRatios();
        this.updateDarkness();
        this.updateBrightness();
      },
      darkness: function() {
        this.updateChannelsDark();
      },
      brightness: function() {
        this.updateChannelsBright();
      }
    },

    methods: {

      // TODO: should really only be called when the top 3 sliders are changed
      updateRatios: function() {
        var max = Math.max(this.channel_R, this.channel_G, this.channel_B);
        var min = Math.min(this.channel_R, this.channel_G, this.channel_B);
        if (max == 0) max = 1; // to prevent divide by zero errors
        if (min == 255) min = 254; // to prevent divide by zero errors
        this.dark_ratios[0] = this.channel_R / max;
        this.dark_ratios[1] = this.channel_G / max;
        this.dark_ratios[2] = this.channel_B / max;

        this.bright_ratios[0] = (255 - this.channel_R) / (255 - min);
        this.bright_ratios[1] = (255 - this.channel_G) / (255 - min);
        this.bright_ratios[2] = (255 - this.channel_B) / (255 - min);

      },
      updateDarkness: function() {
        this.darkness = Math.max(this.channel_R, this.channel_G, this.channel_B);
      },
      updateBrightness: function() {
        this.brightness = Math.min(this.channel_R, this.channel_G, this.channel_B);
      },
      updateChannelsDark: function() {
        this.channel_R = Math.round(this.dark_ratios[0] * this.darkness);
        this.channel_G = Math.round(this.dark_ratios[1] * this.darkness);
        this.channel_B = Math.round(this.dark_ratios[2] * this.darkness);
      },
      updateChannelsBright: function() {
        this.channel_R = Math.round(255 - this.bright_ratios[0] * (255 - this.brightness));
        this.channel_G = Math.round(255 - this.bright_ratios[1] * (255 - this.brightness));
        this.channel_B = Math.round(255 - this.bright_ratios[2] * (255 - this.brightness));
      }
    },


    computed:{
        // colorStyle is used in the stylesheet for this component
        colorStyle: function(){
          return 'rgba('+ this.channel_R+','+ this.channel_G+','+ this.channel_B+', 1)';
        }
    }
  })
</script>
<body>
